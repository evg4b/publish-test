package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/evg4b/uncors/internal/server.Listner -o ./listner_mock.go -n ListnerMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ListnerMock implements server.Listner
type ListnerMock struct {
	t minimock.Tester

	funcListenAndServe          func() (err error)
	inspectFuncListenAndServe   func()
	afterListenAndServeCounter  uint64
	beforeListenAndServeCounter uint64
	ListenAndServeMock          mListnerMockListenAndServe

	funcListenAndServeTLS          func(certFile string, keyFile string) (err error)
	inspectFuncListenAndServeTLS   func(certFile string, keyFile string)
	afterListenAndServeTLSCounter  uint64
	beforeListenAndServeTLSCounter uint64
	ListenAndServeTLSMock          mListnerMockListenAndServeTLS

	funcShutdown          func(ctx context.Context) (err error)
	inspectFuncShutdown   func(ctx context.Context)
	afterShutdownCounter  uint64
	beforeShutdownCounter uint64
	ShutdownMock          mListnerMockShutdown
}

// NewListnerMock returns a mock for server.Listner
func NewListnerMock(t minimock.Tester) *ListnerMock {
	m := &ListnerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ListenAndServeMock = mListnerMockListenAndServe{mock: m}

	m.ListenAndServeTLSMock = mListnerMockListenAndServeTLS{mock: m}
	m.ListenAndServeTLSMock.callArgs = []*ListnerMockListenAndServeTLSParams{}

	m.ShutdownMock = mListnerMockShutdown{mock: m}
	m.ShutdownMock.callArgs = []*ListnerMockShutdownParams{}

	return m
}

type mListnerMockListenAndServe struct {
	mock               *ListnerMock
	defaultExpectation *ListnerMockListenAndServeExpectation
	expectations       []*ListnerMockListenAndServeExpectation
}

// ListnerMockListenAndServeExpectation specifies expectation struct of the Listner.ListenAndServe
type ListnerMockListenAndServeExpectation struct {
	mock *ListnerMock

	results *ListnerMockListenAndServeResults
	Counter uint64
}

// ListnerMockListenAndServeResults contains results of the Listner.ListenAndServe
type ListnerMockListenAndServeResults struct {
	err error
}

// Expect sets up expected params for Listner.ListenAndServe
func (mmListenAndServe *mListnerMockListenAndServe) Expect() *mListnerMockListenAndServe {
	if mmListenAndServe.mock.funcListenAndServe != nil {
		mmListenAndServe.mock.t.Fatalf("ListnerMock.ListenAndServe mock is already set by Set")
	}

	if mmListenAndServe.defaultExpectation == nil {
		mmListenAndServe.defaultExpectation = &ListnerMockListenAndServeExpectation{}
	}

	return mmListenAndServe
}

// Inspect accepts an inspector function that has same arguments as the Listner.ListenAndServe
func (mmListenAndServe *mListnerMockListenAndServe) Inspect(f func()) *mListnerMockListenAndServe {
	if mmListenAndServe.mock.inspectFuncListenAndServe != nil {
		mmListenAndServe.mock.t.Fatalf("Inspect function is already set for ListnerMock.ListenAndServe")
	}

	mmListenAndServe.mock.inspectFuncListenAndServe = f

	return mmListenAndServe
}

// Return sets up results that will be returned by Listner.ListenAndServe
func (mmListenAndServe *mListnerMockListenAndServe) Return(err error) *ListnerMock {
	if mmListenAndServe.mock.funcListenAndServe != nil {
		mmListenAndServe.mock.t.Fatalf("ListnerMock.ListenAndServe mock is already set by Set")
	}

	if mmListenAndServe.defaultExpectation == nil {
		mmListenAndServe.defaultExpectation = &ListnerMockListenAndServeExpectation{mock: mmListenAndServe.mock}
	}
	mmListenAndServe.defaultExpectation.results = &ListnerMockListenAndServeResults{err}
	return mmListenAndServe.mock
}

//Set uses given function f to mock the Listner.ListenAndServe method
func (mmListenAndServe *mListnerMockListenAndServe) Set(f func() (err error)) *ListnerMock {
	if mmListenAndServe.defaultExpectation != nil {
		mmListenAndServe.mock.t.Fatalf("Default expectation is already set for the Listner.ListenAndServe method")
	}

	if len(mmListenAndServe.expectations) > 0 {
		mmListenAndServe.mock.t.Fatalf("Some expectations are already set for the Listner.ListenAndServe method")
	}

	mmListenAndServe.mock.funcListenAndServe = f
	return mmListenAndServe.mock
}

// ListenAndServe implements server.Listner
func (mmListenAndServe *ListnerMock) ListenAndServe() (err error) {
	mm_atomic.AddUint64(&mmListenAndServe.beforeListenAndServeCounter, 1)
	defer mm_atomic.AddUint64(&mmListenAndServe.afterListenAndServeCounter, 1)

	if mmListenAndServe.inspectFuncListenAndServe != nil {
		mmListenAndServe.inspectFuncListenAndServe()
	}

	if mmListenAndServe.ListenAndServeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListenAndServe.ListenAndServeMock.defaultExpectation.Counter, 1)

		mm_results := mmListenAndServe.ListenAndServeMock.defaultExpectation.results
		if mm_results == nil {
			mmListenAndServe.t.Fatal("No results are set for the ListnerMock.ListenAndServe")
		}
		return (*mm_results).err
	}
	if mmListenAndServe.funcListenAndServe != nil {
		return mmListenAndServe.funcListenAndServe()
	}
	mmListenAndServe.t.Fatalf("Unexpected call to ListnerMock.ListenAndServe.")
	return
}

// ListenAndServeAfterCounter returns a count of finished ListnerMock.ListenAndServe invocations
func (mmListenAndServe *ListnerMock) ListenAndServeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServe.afterListenAndServeCounter)
}

// ListenAndServeBeforeCounter returns a count of ListnerMock.ListenAndServe invocations
func (mmListenAndServe *ListnerMock) ListenAndServeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServe.beforeListenAndServeCounter)
}

// MinimockListenAndServeDone returns true if the count of the ListenAndServe invocations corresponds
// the number of defined expectations
func (m *ListnerMock) MinimockListenAndServeDone() bool {
	for _, e := range m.ListenAndServeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServe != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		return false
	}
	return true
}

// MinimockListenAndServeInspect logs each unmet expectation
func (m *ListnerMock) MinimockListenAndServeInspect() {
	for _, e := range m.ListenAndServeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ListnerMock.ListenAndServe")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		m.t.Error("Expected call to ListnerMock.ListenAndServe")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServe != nil && mm_atomic.LoadUint64(&m.afterListenAndServeCounter) < 1 {
		m.t.Error("Expected call to ListnerMock.ListenAndServe")
	}
}

type mListnerMockListenAndServeTLS struct {
	mock               *ListnerMock
	defaultExpectation *ListnerMockListenAndServeTLSExpectation
	expectations       []*ListnerMockListenAndServeTLSExpectation

	callArgs []*ListnerMockListenAndServeTLSParams
	mutex    sync.RWMutex
}

// ListnerMockListenAndServeTLSExpectation specifies expectation struct of the Listner.ListenAndServeTLS
type ListnerMockListenAndServeTLSExpectation struct {
	mock    *ListnerMock
	params  *ListnerMockListenAndServeTLSParams
	results *ListnerMockListenAndServeTLSResults
	Counter uint64
}

// ListnerMockListenAndServeTLSParams contains parameters of the Listner.ListenAndServeTLS
type ListnerMockListenAndServeTLSParams struct {
	certFile string
	keyFile  string
}

// ListnerMockListenAndServeTLSResults contains results of the Listner.ListenAndServeTLS
type ListnerMockListenAndServeTLSResults struct {
	err error
}

// Expect sets up expected params for Listner.ListenAndServeTLS
func (mmListenAndServeTLS *mListnerMockListenAndServeTLS) Expect(certFile string, keyFile string) *mListnerMockListenAndServeTLS {
	if mmListenAndServeTLS.mock.funcListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("ListnerMock.ListenAndServeTLS mock is already set by Set")
	}

	if mmListenAndServeTLS.defaultExpectation == nil {
		mmListenAndServeTLS.defaultExpectation = &ListnerMockListenAndServeTLSExpectation{}
	}

	mmListenAndServeTLS.defaultExpectation.params = &ListnerMockListenAndServeTLSParams{certFile, keyFile}
	for _, e := range mmListenAndServeTLS.expectations {
		if minimock.Equal(e.params, mmListenAndServeTLS.defaultExpectation.params) {
			mmListenAndServeTLS.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListenAndServeTLS.defaultExpectation.params)
		}
	}

	return mmListenAndServeTLS
}

// Inspect accepts an inspector function that has same arguments as the Listner.ListenAndServeTLS
func (mmListenAndServeTLS *mListnerMockListenAndServeTLS) Inspect(f func(certFile string, keyFile string)) *mListnerMockListenAndServeTLS {
	if mmListenAndServeTLS.mock.inspectFuncListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("Inspect function is already set for ListnerMock.ListenAndServeTLS")
	}

	mmListenAndServeTLS.mock.inspectFuncListenAndServeTLS = f

	return mmListenAndServeTLS
}

// Return sets up results that will be returned by Listner.ListenAndServeTLS
func (mmListenAndServeTLS *mListnerMockListenAndServeTLS) Return(err error) *ListnerMock {
	if mmListenAndServeTLS.mock.funcListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("ListnerMock.ListenAndServeTLS mock is already set by Set")
	}

	if mmListenAndServeTLS.defaultExpectation == nil {
		mmListenAndServeTLS.defaultExpectation = &ListnerMockListenAndServeTLSExpectation{mock: mmListenAndServeTLS.mock}
	}
	mmListenAndServeTLS.defaultExpectation.results = &ListnerMockListenAndServeTLSResults{err}
	return mmListenAndServeTLS.mock
}

//Set uses given function f to mock the Listner.ListenAndServeTLS method
func (mmListenAndServeTLS *mListnerMockListenAndServeTLS) Set(f func(certFile string, keyFile string) (err error)) *ListnerMock {
	if mmListenAndServeTLS.defaultExpectation != nil {
		mmListenAndServeTLS.mock.t.Fatalf("Default expectation is already set for the Listner.ListenAndServeTLS method")
	}

	if len(mmListenAndServeTLS.expectations) > 0 {
		mmListenAndServeTLS.mock.t.Fatalf("Some expectations are already set for the Listner.ListenAndServeTLS method")
	}

	mmListenAndServeTLS.mock.funcListenAndServeTLS = f
	return mmListenAndServeTLS.mock
}

// When sets expectation for the Listner.ListenAndServeTLS which will trigger the result defined by the following
// Then helper
func (mmListenAndServeTLS *mListnerMockListenAndServeTLS) When(certFile string, keyFile string) *ListnerMockListenAndServeTLSExpectation {
	if mmListenAndServeTLS.mock.funcListenAndServeTLS != nil {
		mmListenAndServeTLS.mock.t.Fatalf("ListnerMock.ListenAndServeTLS mock is already set by Set")
	}

	expectation := &ListnerMockListenAndServeTLSExpectation{
		mock:   mmListenAndServeTLS.mock,
		params: &ListnerMockListenAndServeTLSParams{certFile, keyFile},
	}
	mmListenAndServeTLS.expectations = append(mmListenAndServeTLS.expectations, expectation)
	return expectation
}

// Then sets up Listner.ListenAndServeTLS return parameters for the expectation previously defined by the When method
func (e *ListnerMockListenAndServeTLSExpectation) Then(err error) *ListnerMock {
	e.results = &ListnerMockListenAndServeTLSResults{err}
	return e.mock
}

// ListenAndServeTLS implements server.Listner
func (mmListenAndServeTLS *ListnerMock) ListenAndServeTLS(certFile string, keyFile string) (err error) {
	mm_atomic.AddUint64(&mmListenAndServeTLS.beforeListenAndServeTLSCounter, 1)
	defer mm_atomic.AddUint64(&mmListenAndServeTLS.afterListenAndServeTLSCounter, 1)

	if mmListenAndServeTLS.inspectFuncListenAndServeTLS != nil {
		mmListenAndServeTLS.inspectFuncListenAndServeTLS(certFile, keyFile)
	}

	mm_params := &ListnerMockListenAndServeTLSParams{certFile, keyFile}

	// Record call args
	mmListenAndServeTLS.ListenAndServeTLSMock.mutex.Lock()
	mmListenAndServeTLS.ListenAndServeTLSMock.callArgs = append(mmListenAndServeTLS.ListenAndServeTLSMock.callArgs, mm_params)
	mmListenAndServeTLS.ListenAndServeTLSMock.mutex.Unlock()

	for _, e := range mmListenAndServeTLS.ListenAndServeTLSMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation.Counter, 1)
		mm_want := mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation.params
		mm_got := ListnerMockListenAndServeTLSParams{certFile, keyFile}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListenAndServeTLS.t.Errorf("ListnerMock.ListenAndServeTLS got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListenAndServeTLS.ListenAndServeTLSMock.defaultExpectation.results
		if mm_results == nil {
			mmListenAndServeTLS.t.Fatal("No results are set for the ListnerMock.ListenAndServeTLS")
		}
		return (*mm_results).err
	}
	if mmListenAndServeTLS.funcListenAndServeTLS != nil {
		return mmListenAndServeTLS.funcListenAndServeTLS(certFile, keyFile)
	}
	mmListenAndServeTLS.t.Fatalf("Unexpected call to ListnerMock.ListenAndServeTLS. %v %v", certFile, keyFile)
	return
}

// ListenAndServeTLSAfterCounter returns a count of finished ListnerMock.ListenAndServeTLS invocations
func (mmListenAndServeTLS *ListnerMock) ListenAndServeTLSAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServeTLS.afterListenAndServeTLSCounter)
}

// ListenAndServeTLSBeforeCounter returns a count of ListnerMock.ListenAndServeTLS invocations
func (mmListenAndServeTLS *ListnerMock) ListenAndServeTLSBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListenAndServeTLS.beforeListenAndServeTLSCounter)
}

// Calls returns a list of arguments used in each call to ListnerMock.ListenAndServeTLS.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListenAndServeTLS *mListnerMockListenAndServeTLS) Calls() []*ListnerMockListenAndServeTLSParams {
	mmListenAndServeTLS.mutex.RLock()

	argCopy := make([]*ListnerMockListenAndServeTLSParams, len(mmListenAndServeTLS.callArgs))
	copy(argCopy, mmListenAndServeTLS.callArgs)

	mmListenAndServeTLS.mutex.RUnlock()

	return argCopy
}

// MinimockListenAndServeTLSDone returns true if the count of the ListenAndServeTLS invocations corresponds
// the number of defined expectations
func (m *ListnerMock) MinimockListenAndServeTLSDone() bool {
	for _, e := range m.ListenAndServeTLSMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeTLSMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServeTLS != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		return false
	}
	return true
}

// MinimockListenAndServeTLSInspect logs each unmet expectation
func (m *ListnerMock) MinimockListenAndServeTLSInspect() {
	for _, e := range m.ListenAndServeTLSMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListnerMock.ListenAndServeTLS with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListenAndServeTLSMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		if m.ListenAndServeTLSMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ListnerMock.ListenAndServeTLS")
		} else {
			m.t.Errorf("Expected call to ListnerMock.ListenAndServeTLS with params: %#v", *m.ListenAndServeTLSMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListenAndServeTLS != nil && mm_atomic.LoadUint64(&m.afterListenAndServeTLSCounter) < 1 {
		m.t.Error("Expected call to ListnerMock.ListenAndServeTLS")
	}
}

type mListnerMockShutdown struct {
	mock               *ListnerMock
	defaultExpectation *ListnerMockShutdownExpectation
	expectations       []*ListnerMockShutdownExpectation

	callArgs []*ListnerMockShutdownParams
	mutex    sync.RWMutex
}

// ListnerMockShutdownExpectation specifies expectation struct of the Listner.Shutdown
type ListnerMockShutdownExpectation struct {
	mock    *ListnerMock
	params  *ListnerMockShutdownParams
	results *ListnerMockShutdownResults
	Counter uint64
}

// ListnerMockShutdownParams contains parameters of the Listner.Shutdown
type ListnerMockShutdownParams struct {
	ctx context.Context
}

// ListnerMockShutdownResults contains results of the Listner.Shutdown
type ListnerMockShutdownResults struct {
	err error
}

// Expect sets up expected params for Listner.Shutdown
func (mmShutdown *mListnerMockShutdown) Expect(ctx context.Context) *mListnerMockShutdown {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("ListnerMock.Shutdown mock is already set by Set")
	}

	if mmShutdown.defaultExpectation == nil {
		mmShutdown.defaultExpectation = &ListnerMockShutdownExpectation{}
	}

	mmShutdown.defaultExpectation.params = &ListnerMockShutdownParams{ctx}
	for _, e := range mmShutdown.expectations {
		if minimock.Equal(e.params, mmShutdown.defaultExpectation.params) {
			mmShutdown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmShutdown.defaultExpectation.params)
		}
	}

	return mmShutdown
}

// Inspect accepts an inspector function that has same arguments as the Listner.Shutdown
func (mmShutdown *mListnerMockShutdown) Inspect(f func(ctx context.Context)) *mListnerMockShutdown {
	if mmShutdown.mock.inspectFuncShutdown != nil {
		mmShutdown.mock.t.Fatalf("Inspect function is already set for ListnerMock.Shutdown")
	}

	mmShutdown.mock.inspectFuncShutdown = f

	return mmShutdown
}

// Return sets up results that will be returned by Listner.Shutdown
func (mmShutdown *mListnerMockShutdown) Return(err error) *ListnerMock {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("ListnerMock.Shutdown mock is already set by Set")
	}

	if mmShutdown.defaultExpectation == nil {
		mmShutdown.defaultExpectation = &ListnerMockShutdownExpectation{mock: mmShutdown.mock}
	}
	mmShutdown.defaultExpectation.results = &ListnerMockShutdownResults{err}
	return mmShutdown.mock
}

//Set uses given function f to mock the Listner.Shutdown method
func (mmShutdown *mListnerMockShutdown) Set(f func(ctx context.Context) (err error)) *ListnerMock {
	if mmShutdown.defaultExpectation != nil {
		mmShutdown.mock.t.Fatalf("Default expectation is already set for the Listner.Shutdown method")
	}

	if len(mmShutdown.expectations) > 0 {
		mmShutdown.mock.t.Fatalf("Some expectations are already set for the Listner.Shutdown method")
	}

	mmShutdown.mock.funcShutdown = f
	return mmShutdown.mock
}

// When sets expectation for the Listner.Shutdown which will trigger the result defined by the following
// Then helper
func (mmShutdown *mListnerMockShutdown) When(ctx context.Context) *ListnerMockShutdownExpectation {
	if mmShutdown.mock.funcShutdown != nil {
		mmShutdown.mock.t.Fatalf("ListnerMock.Shutdown mock is already set by Set")
	}

	expectation := &ListnerMockShutdownExpectation{
		mock:   mmShutdown.mock,
		params: &ListnerMockShutdownParams{ctx},
	}
	mmShutdown.expectations = append(mmShutdown.expectations, expectation)
	return expectation
}

// Then sets up Listner.Shutdown return parameters for the expectation previously defined by the When method
func (e *ListnerMockShutdownExpectation) Then(err error) *ListnerMock {
	e.results = &ListnerMockShutdownResults{err}
	return e.mock
}

// Shutdown implements server.Listner
func (mmShutdown *ListnerMock) Shutdown(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmShutdown.beforeShutdownCounter, 1)
	defer mm_atomic.AddUint64(&mmShutdown.afterShutdownCounter, 1)

	if mmShutdown.inspectFuncShutdown != nil {
		mmShutdown.inspectFuncShutdown(ctx)
	}

	mm_params := &ListnerMockShutdownParams{ctx}

	// Record call args
	mmShutdown.ShutdownMock.mutex.Lock()
	mmShutdown.ShutdownMock.callArgs = append(mmShutdown.ShutdownMock.callArgs, mm_params)
	mmShutdown.ShutdownMock.mutex.Unlock()

	for _, e := range mmShutdown.ShutdownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmShutdown.ShutdownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmShutdown.ShutdownMock.defaultExpectation.Counter, 1)
		mm_want := mmShutdown.ShutdownMock.defaultExpectation.params
		mm_got := ListnerMockShutdownParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmShutdown.t.Errorf("ListnerMock.Shutdown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmShutdown.ShutdownMock.defaultExpectation.results
		if mm_results == nil {
			mmShutdown.t.Fatal("No results are set for the ListnerMock.Shutdown")
		}
		return (*mm_results).err
	}
	if mmShutdown.funcShutdown != nil {
		return mmShutdown.funcShutdown(ctx)
	}
	mmShutdown.t.Fatalf("Unexpected call to ListnerMock.Shutdown. %v", ctx)
	return
}

// ShutdownAfterCounter returns a count of finished ListnerMock.Shutdown invocations
func (mmShutdown *ListnerMock) ShutdownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutdown.afterShutdownCounter)
}

// ShutdownBeforeCounter returns a count of ListnerMock.Shutdown invocations
func (mmShutdown *ListnerMock) ShutdownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmShutdown.beforeShutdownCounter)
}

// Calls returns a list of arguments used in each call to ListnerMock.Shutdown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmShutdown *mListnerMockShutdown) Calls() []*ListnerMockShutdownParams {
	mmShutdown.mutex.RLock()

	argCopy := make([]*ListnerMockShutdownParams, len(mmShutdown.callArgs))
	copy(argCopy, mmShutdown.callArgs)

	mmShutdown.mutex.RUnlock()

	return argCopy
}

// MinimockShutdownDone returns true if the count of the Shutdown invocations corresponds
// the number of defined expectations
func (m *ListnerMock) MinimockShutdownDone() bool {
	for _, e := range m.ShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShutdownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutdown != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		return false
	}
	return true
}

// MinimockShutdownInspect logs each unmet expectation
func (m *ListnerMock) MinimockShutdownInspect() {
	for _, e := range m.ShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ListnerMock.Shutdown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ShutdownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		if m.ShutdownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ListnerMock.Shutdown")
		} else {
			m.t.Errorf("Expected call to ListnerMock.Shutdown with params: %#v", *m.ShutdownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcShutdown != nil && mm_atomic.LoadUint64(&m.afterShutdownCounter) < 1 {
		m.t.Error("Expected call to ListnerMock.Shutdown")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ListnerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockListenAndServeInspect()

		m.MinimockListenAndServeTLSInspect()

		m.MinimockShutdownInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ListnerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ListnerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockListenAndServeDone() &&
		m.MinimockListenAndServeTLSDone() &&
		m.MinimockShutdownDone()
}
