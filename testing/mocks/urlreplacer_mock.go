package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/evg4b/uncors/internal/urlreplacer.URLReplacer -o ./urlreplacer_mock.go -n URLReplacerMock

import (
	"net/url"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// URLReplacerMock implements urlreplacer.URLReplacer
type URLReplacerMock struct {
	t minimock.Tester

	funcToSource          func(rawURL string) (s1 string, err error)
	inspectFuncToSource   func(rawURL string)
	afterToSourceCounter  uint64
	beforeToSourceCounter uint64
	ToSourceMock          mURLReplacerMockToSource

	funcToTarget          func(rawURL string) (s1 string, err error)
	inspectFuncToTarget   func(rawURL string)
	afterToTargetCounter  uint64
	beforeToTargetCounter uint64
	ToTargetMock          mURLReplacerMockToTarget

	funcURLToSource          func(parsedURL *url.URL) (s1 string, err error)
	inspectFuncURLToSource   func(parsedURL *url.URL)
	afterURLToSourceCounter  uint64
	beforeURLToSourceCounter uint64
	URLToSourceMock          mURLReplacerMockURLToSource

	funcURLToTarget          func(parsedURL *url.URL) (s1 string, err error)
	inspectFuncURLToTarget   func(parsedURL *url.URL)
	afterURLToTargetCounter  uint64
	beforeURLToTargetCounter uint64
	URLToTargetMock          mURLReplacerMockURLToTarget
}

// NewURLReplacerMock returns a mock for urlreplacer.URLReplacer
func NewURLReplacerMock(t minimock.Tester) *URLReplacerMock {
	m := &URLReplacerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ToSourceMock = mURLReplacerMockToSource{mock: m}
	m.ToSourceMock.callArgs = []*URLReplacerMockToSourceParams{}

	m.ToTargetMock = mURLReplacerMockToTarget{mock: m}
	m.ToTargetMock.callArgs = []*URLReplacerMockToTargetParams{}

	m.URLToSourceMock = mURLReplacerMockURLToSource{mock: m}
	m.URLToSourceMock.callArgs = []*URLReplacerMockURLToSourceParams{}

	m.URLToTargetMock = mURLReplacerMockURLToTarget{mock: m}
	m.URLToTargetMock.callArgs = []*URLReplacerMockURLToTargetParams{}

	return m
}

type mURLReplacerMockToSource struct {
	mock               *URLReplacerMock
	defaultExpectation *URLReplacerMockToSourceExpectation
	expectations       []*URLReplacerMockToSourceExpectation

	callArgs []*URLReplacerMockToSourceParams
	mutex    sync.RWMutex
}

// URLReplacerMockToSourceExpectation specifies expectation struct of the URLReplacer.ToSource
type URLReplacerMockToSourceExpectation struct {
	mock    *URLReplacerMock
	params  *URLReplacerMockToSourceParams
	results *URLReplacerMockToSourceResults
	Counter uint64
}

// URLReplacerMockToSourceParams contains parameters of the URLReplacer.ToSource
type URLReplacerMockToSourceParams struct {
	rawURL string
}

// URLReplacerMockToSourceResults contains results of the URLReplacer.ToSource
type URLReplacerMockToSourceResults struct {
	s1  string
	err error
}

// Expect sets up expected params for URLReplacer.ToSource
func (mmToSource *mURLReplacerMockToSource) Expect(rawURL string) *mURLReplacerMockToSource {
	if mmToSource.mock.funcToSource != nil {
		mmToSource.mock.t.Fatalf("URLReplacerMock.ToSource mock is already set by Set")
	}

	if mmToSource.defaultExpectation == nil {
		mmToSource.defaultExpectation = &URLReplacerMockToSourceExpectation{}
	}

	mmToSource.defaultExpectation.params = &URLReplacerMockToSourceParams{rawURL}
	for _, e := range mmToSource.expectations {
		if minimock.Equal(e.params, mmToSource.defaultExpectation.params) {
			mmToSource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToSource.defaultExpectation.params)
		}
	}

	return mmToSource
}

// Inspect accepts an inspector function that has same arguments as the URLReplacer.ToSource
func (mmToSource *mURLReplacerMockToSource) Inspect(f func(rawURL string)) *mURLReplacerMockToSource {
	if mmToSource.mock.inspectFuncToSource != nil {
		mmToSource.mock.t.Fatalf("Inspect function is already set for URLReplacerMock.ToSource")
	}

	mmToSource.mock.inspectFuncToSource = f

	return mmToSource
}

// Return sets up results that will be returned by URLReplacer.ToSource
func (mmToSource *mURLReplacerMockToSource) Return(s1 string, err error) *URLReplacerMock {
	if mmToSource.mock.funcToSource != nil {
		mmToSource.mock.t.Fatalf("URLReplacerMock.ToSource mock is already set by Set")
	}

	if mmToSource.defaultExpectation == nil {
		mmToSource.defaultExpectation = &URLReplacerMockToSourceExpectation{mock: mmToSource.mock}
	}
	mmToSource.defaultExpectation.results = &URLReplacerMockToSourceResults{s1, err}
	return mmToSource.mock
}

//Set uses given function f to mock the URLReplacer.ToSource method
func (mmToSource *mURLReplacerMockToSource) Set(f func(rawURL string) (s1 string, err error)) *URLReplacerMock {
	if mmToSource.defaultExpectation != nil {
		mmToSource.mock.t.Fatalf("Default expectation is already set for the URLReplacer.ToSource method")
	}

	if len(mmToSource.expectations) > 0 {
		mmToSource.mock.t.Fatalf("Some expectations are already set for the URLReplacer.ToSource method")
	}

	mmToSource.mock.funcToSource = f
	return mmToSource.mock
}

// When sets expectation for the URLReplacer.ToSource which will trigger the result defined by the following
// Then helper
func (mmToSource *mURLReplacerMockToSource) When(rawURL string) *URLReplacerMockToSourceExpectation {
	if mmToSource.mock.funcToSource != nil {
		mmToSource.mock.t.Fatalf("URLReplacerMock.ToSource mock is already set by Set")
	}

	expectation := &URLReplacerMockToSourceExpectation{
		mock:   mmToSource.mock,
		params: &URLReplacerMockToSourceParams{rawURL},
	}
	mmToSource.expectations = append(mmToSource.expectations, expectation)
	return expectation
}

// Then sets up URLReplacer.ToSource return parameters for the expectation previously defined by the When method
func (e *URLReplacerMockToSourceExpectation) Then(s1 string, err error) *URLReplacerMock {
	e.results = &URLReplacerMockToSourceResults{s1, err}
	return e.mock
}

// ToSource implements urlreplacer.URLReplacer
func (mmToSource *URLReplacerMock) ToSource(rawURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmToSource.beforeToSourceCounter, 1)
	defer mm_atomic.AddUint64(&mmToSource.afterToSourceCounter, 1)

	if mmToSource.inspectFuncToSource != nil {
		mmToSource.inspectFuncToSource(rawURL)
	}

	mm_params := &URLReplacerMockToSourceParams{rawURL}

	// Record call args
	mmToSource.ToSourceMock.mutex.Lock()
	mmToSource.ToSourceMock.callArgs = append(mmToSource.ToSourceMock.callArgs, mm_params)
	mmToSource.ToSourceMock.mutex.Unlock()

	for _, e := range mmToSource.ToSourceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmToSource.ToSourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToSource.ToSourceMock.defaultExpectation.Counter, 1)
		mm_want := mmToSource.ToSourceMock.defaultExpectation.params
		mm_got := URLReplacerMockToSourceParams{rawURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToSource.t.Errorf("URLReplacerMock.ToSource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToSource.ToSourceMock.defaultExpectation.results
		if mm_results == nil {
			mmToSource.t.Fatal("No results are set for the URLReplacerMock.ToSource")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmToSource.funcToSource != nil {
		return mmToSource.funcToSource(rawURL)
	}
	mmToSource.t.Fatalf("Unexpected call to URLReplacerMock.ToSource. %v", rawURL)
	return
}

// ToSourceAfterCounter returns a count of finished URLReplacerMock.ToSource invocations
func (mmToSource *URLReplacerMock) ToSourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToSource.afterToSourceCounter)
}

// ToSourceBeforeCounter returns a count of URLReplacerMock.ToSource invocations
func (mmToSource *URLReplacerMock) ToSourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToSource.beforeToSourceCounter)
}

// Calls returns a list of arguments used in each call to URLReplacerMock.ToSource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToSource *mURLReplacerMockToSource) Calls() []*URLReplacerMockToSourceParams {
	mmToSource.mutex.RLock()

	argCopy := make([]*URLReplacerMockToSourceParams, len(mmToSource.callArgs))
	copy(argCopy, mmToSource.callArgs)

	mmToSource.mutex.RUnlock()

	return argCopy
}

// MinimockToSourceDone returns true if the count of the ToSource invocations corresponds
// the number of defined expectations
func (m *URLReplacerMock) MinimockToSourceDone() bool {
	for _, e := range m.ToSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ToSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterToSourceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToSource != nil && mm_atomic.LoadUint64(&m.afterToSourceCounter) < 1 {
		return false
	}
	return true
}

// MinimockToSourceInspect logs each unmet expectation
func (m *URLReplacerMock) MinimockToSourceInspect() {
	for _, e := range m.ToSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLReplacerMock.ToSource with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ToSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterToSourceCounter) < 1 {
		if m.ToSourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLReplacerMock.ToSource")
		} else {
			m.t.Errorf("Expected call to URLReplacerMock.ToSource with params: %#v", *m.ToSourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToSource != nil && mm_atomic.LoadUint64(&m.afterToSourceCounter) < 1 {
		m.t.Error("Expected call to URLReplacerMock.ToSource")
	}
}

type mURLReplacerMockToTarget struct {
	mock               *URLReplacerMock
	defaultExpectation *URLReplacerMockToTargetExpectation
	expectations       []*URLReplacerMockToTargetExpectation

	callArgs []*URLReplacerMockToTargetParams
	mutex    sync.RWMutex
}

// URLReplacerMockToTargetExpectation specifies expectation struct of the URLReplacer.ToTarget
type URLReplacerMockToTargetExpectation struct {
	mock    *URLReplacerMock
	params  *URLReplacerMockToTargetParams
	results *URLReplacerMockToTargetResults
	Counter uint64
}

// URLReplacerMockToTargetParams contains parameters of the URLReplacer.ToTarget
type URLReplacerMockToTargetParams struct {
	rawURL string
}

// URLReplacerMockToTargetResults contains results of the URLReplacer.ToTarget
type URLReplacerMockToTargetResults struct {
	s1  string
	err error
}

// Expect sets up expected params for URLReplacer.ToTarget
func (mmToTarget *mURLReplacerMockToTarget) Expect(rawURL string) *mURLReplacerMockToTarget {
	if mmToTarget.mock.funcToTarget != nil {
		mmToTarget.mock.t.Fatalf("URLReplacerMock.ToTarget mock is already set by Set")
	}

	if mmToTarget.defaultExpectation == nil {
		mmToTarget.defaultExpectation = &URLReplacerMockToTargetExpectation{}
	}

	mmToTarget.defaultExpectation.params = &URLReplacerMockToTargetParams{rawURL}
	for _, e := range mmToTarget.expectations {
		if minimock.Equal(e.params, mmToTarget.defaultExpectation.params) {
			mmToTarget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmToTarget.defaultExpectation.params)
		}
	}

	return mmToTarget
}

// Inspect accepts an inspector function that has same arguments as the URLReplacer.ToTarget
func (mmToTarget *mURLReplacerMockToTarget) Inspect(f func(rawURL string)) *mURLReplacerMockToTarget {
	if mmToTarget.mock.inspectFuncToTarget != nil {
		mmToTarget.mock.t.Fatalf("Inspect function is already set for URLReplacerMock.ToTarget")
	}

	mmToTarget.mock.inspectFuncToTarget = f

	return mmToTarget
}

// Return sets up results that will be returned by URLReplacer.ToTarget
func (mmToTarget *mURLReplacerMockToTarget) Return(s1 string, err error) *URLReplacerMock {
	if mmToTarget.mock.funcToTarget != nil {
		mmToTarget.mock.t.Fatalf("URLReplacerMock.ToTarget mock is already set by Set")
	}

	if mmToTarget.defaultExpectation == nil {
		mmToTarget.defaultExpectation = &URLReplacerMockToTargetExpectation{mock: mmToTarget.mock}
	}
	mmToTarget.defaultExpectation.results = &URLReplacerMockToTargetResults{s1, err}
	return mmToTarget.mock
}

//Set uses given function f to mock the URLReplacer.ToTarget method
func (mmToTarget *mURLReplacerMockToTarget) Set(f func(rawURL string) (s1 string, err error)) *URLReplacerMock {
	if mmToTarget.defaultExpectation != nil {
		mmToTarget.mock.t.Fatalf("Default expectation is already set for the URLReplacer.ToTarget method")
	}

	if len(mmToTarget.expectations) > 0 {
		mmToTarget.mock.t.Fatalf("Some expectations are already set for the URLReplacer.ToTarget method")
	}

	mmToTarget.mock.funcToTarget = f
	return mmToTarget.mock
}

// When sets expectation for the URLReplacer.ToTarget which will trigger the result defined by the following
// Then helper
func (mmToTarget *mURLReplacerMockToTarget) When(rawURL string) *URLReplacerMockToTargetExpectation {
	if mmToTarget.mock.funcToTarget != nil {
		mmToTarget.mock.t.Fatalf("URLReplacerMock.ToTarget mock is already set by Set")
	}

	expectation := &URLReplacerMockToTargetExpectation{
		mock:   mmToTarget.mock,
		params: &URLReplacerMockToTargetParams{rawURL},
	}
	mmToTarget.expectations = append(mmToTarget.expectations, expectation)
	return expectation
}

// Then sets up URLReplacer.ToTarget return parameters for the expectation previously defined by the When method
func (e *URLReplacerMockToTargetExpectation) Then(s1 string, err error) *URLReplacerMock {
	e.results = &URLReplacerMockToTargetResults{s1, err}
	return e.mock
}

// ToTarget implements urlreplacer.URLReplacer
func (mmToTarget *URLReplacerMock) ToTarget(rawURL string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmToTarget.beforeToTargetCounter, 1)
	defer mm_atomic.AddUint64(&mmToTarget.afterToTargetCounter, 1)

	if mmToTarget.inspectFuncToTarget != nil {
		mmToTarget.inspectFuncToTarget(rawURL)
	}

	mm_params := &URLReplacerMockToTargetParams{rawURL}

	// Record call args
	mmToTarget.ToTargetMock.mutex.Lock()
	mmToTarget.ToTargetMock.callArgs = append(mmToTarget.ToTargetMock.callArgs, mm_params)
	mmToTarget.ToTargetMock.mutex.Unlock()

	for _, e := range mmToTarget.ToTargetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmToTarget.ToTargetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmToTarget.ToTargetMock.defaultExpectation.Counter, 1)
		mm_want := mmToTarget.ToTargetMock.defaultExpectation.params
		mm_got := URLReplacerMockToTargetParams{rawURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmToTarget.t.Errorf("URLReplacerMock.ToTarget got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmToTarget.ToTargetMock.defaultExpectation.results
		if mm_results == nil {
			mmToTarget.t.Fatal("No results are set for the URLReplacerMock.ToTarget")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmToTarget.funcToTarget != nil {
		return mmToTarget.funcToTarget(rawURL)
	}
	mmToTarget.t.Fatalf("Unexpected call to URLReplacerMock.ToTarget. %v", rawURL)
	return
}

// ToTargetAfterCounter returns a count of finished URLReplacerMock.ToTarget invocations
func (mmToTarget *URLReplacerMock) ToTargetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToTarget.afterToTargetCounter)
}

// ToTargetBeforeCounter returns a count of URLReplacerMock.ToTarget invocations
func (mmToTarget *URLReplacerMock) ToTargetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmToTarget.beforeToTargetCounter)
}

// Calls returns a list of arguments used in each call to URLReplacerMock.ToTarget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmToTarget *mURLReplacerMockToTarget) Calls() []*URLReplacerMockToTargetParams {
	mmToTarget.mutex.RLock()

	argCopy := make([]*URLReplacerMockToTargetParams, len(mmToTarget.callArgs))
	copy(argCopy, mmToTarget.callArgs)

	mmToTarget.mutex.RUnlock()

	return argCopy
}

// MinimockToTargetDone returns true if the count of the ToTarget invocations corresponds
// the number of defined expectations
func (m *URLReplacerMock) MinimockToTargetDone() bool {
	for _, e := range m.ToTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ToTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterToTargetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToTarget != nil && mm_atomic.LoadUint64(&m.afterToTargetCounter) < 1 {
		return false
	}
	return true
}

// MinimockToTargetInspect logs each unmet expectation
func (m *URLReplacerMock) MinimockToTargetInspect() {
	for _, e := range m.ToTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLReplacerMock.ToTarget with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ToTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterToTargetCounter) < 1 {
		if m.ToTargetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLReplacerMock.ToTarget")
		} else {
			m.t.Errorf("Expected call to URLReplacerMock.ToTarget with params: %#v", *m.ToTargetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcToTarget != nil && mm_atomic.LoadUint64(&m.afterToTargetCounter) < 1 {
		m.t.Error("Expected call to URLReplacerMock.ToTarget")
	}
}

type mURLReplacerMockURLToSource struct {
	mock               *URLReplacerMock
	defaultExpectation *URLReplacerMockURLToSourceExpectation
	expectations       []*URLReplacerMockURLToSourceExpectation

	callArgs []*URLReplacerMockURLToSourceParams
	mutex    sync.RWMutex
}

// URLReplacerMockURLToSourceExpectation specifies expectation struct of the URLReplacer.URLToSource
type URLReplacerMockURLToSourceExpectation struct {
	mock    *URLReplacerMock
	params  *URLReplacerMockURLToSourceParams
	results *URLReplacerMockURLToSourceResults
	Counter uint64
}

// URLReplacerMockURLToSourceParams contains parameters of the URLReplacer.URLToSource
type URLReplacerMockURLToSourceParams struct {
	parsedURL *url.URL
}

// URLReplacerMockURLToSourceResults contains results of the URLReplacer.URLToSource
type URLReplacerMockURLToSourceResults struct {
	s1  string
	err error
}

// Expect sets up expected params for URLReplacer.URLToSource
func (mmURLToSource *mURLReplacerMockURLToSource) Expect(parsedURL *url.URL) *mURLReplacerMockURLToSource {
	if mmURLToSource.mock.funcURLToSource != nil {
		mmURLToSource.mock.t.Fatalf("URLReplacerMock.URLToSource mock is already set by Set")
	}

	if mmURLToSource.defaultExpectation == nil {
		mmURLToSource.defaultExpectation = &URLReplacerMockURLToSourceExpectation{}
	}

	mmURLToSource.defaultExpectation.params = &URLReplacerMockURLToSourceParams{parsedURL}
	for _, e := range mmURLToSource.expectations {
		if minimock.Equal(e.params, mmURLToSource.defaultExpectation.params) {
			mmURLToSource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmURLToSource.defaultExpectation.params)
		}
	}

	return mmURLToSource
}

// Inspect accepts an inspector function that has same arguments as the URLReplacer.URLToSource
func (mmURLToSource *mURLReplacerMockURLToSource) Inspect(f func(parsedURL *url.URL)) *mURLReplacerMockURLToSource {
	if mmURLToSource.mock.inspectFuncURLToSource != nil {
		mmURLToSource.mock.t.Fatalf("Inspect function is already set for URLReplacerMock.URLToSource")
	}

	mmURLToSource.mock.inspectFuncURLToSource = f

	return mmURLToSource
}

// Return sets up results that will be returned by URLReplacer.URLToSource
func (mmURLToSource *mURLReplacerMockURLToSource) Return(s1 string, err error) *URLReplacerMock {
	if mmURLToSource.mock.funcURLToSource != nil {
		mmURLToSource.mock.t.Fatalf("URLReplacerMock.URLToSource mock is already set by Set")
	}

	if mmURLToSource.defaultExpectation == nil {
		mmURLToSource.defaultExpectation = &URLReplacerMockURLToSourceExpectation{mock: mmURLToSource.mock}
	}
	mmURLToSource.defaultExpectation.results = &URLReplacerMockURLToSourceResults{s1, err}
	return mmURLToSource.mock
}

//Set uses given function f to mock the URLReplacer.URLToSource method
func (mmURLToSource *mURLReplacerMockURLToSource) Set(f func(parsedURL *url.URL) (s1 string, err error)) *URLReplacerMock {
	if mmURLToSource.defaultExpectation != nil {
		mmURLToSource.mock.t.Fatalf("Default expectation is already set for the URLReplacer.URLToSource method")
	}

	if len(mmURLToSource.expectations) > 0 {
		mmURLToSource.mock.t.Fatalf("Some expectations are already set for the URLReplacer.URLToSource method")
	}

	mmURLToSource.mock.funcURLToSource = f
	return mmURLToSource.mock
}

// When sets expectation for the URLReplacer.URLToSource which will trigger the result defined by the following
// Then helper
func (mmURLToSource *mURLReplacerMockURLToSource) When(parsedURL *url.URL) *URLReplacerMockURLToSourceExpectation {
	if mmURLToSource.mock.funcURLToSource != nil {
		mmURLToSource.mock.t.Fatalf("URLReplacerMock.URLToSource mock is already set by Set")
	}

	expectation := &URLReplacerMockURLToSourceExpectation{
		mock:   mmURLToSource.mock,
		params: &URLReplacerMockURLToSourceParams{parsedURL},
	}
	mmURLToSource.expectations = append(mmURLToSource.expectations, expectation)
	return expectation
}

// Then sets up URLReplacer.URLToSource return parameters for the expectation previously defined by the When method
func (e *URLReplacerMockURLToSourceExpectation) Then(s1 string, err error) *URLReplacerMock {
	e.results = &URLReplacerMockURLToSourceResults{s1, err}
	return e.mock
}

// URLToSource implements urlreplacer.URLReplacer
func (mmURLToSource *URLReplacerMock) URLToSource(parsedURL *url.URL) (s1 string, err error) {
	mm_atomic.AddUint64(&mmURLToSource.beforeURLToSourceCounter, 1)
	defer mm_atomic.AddUint64(&mmURLToSource.afterURLToSourceCounter, 1)

	if mmURLToSource.inspectFuncURLToSource != nil {
		mmURLToSource.inspectFuncURLToSource(parsedURL)
	}

	mm_params := &URLReplacerMockURLToSourceParams{parsedURL}

	// Record call args
	mmURLToSource.URLToSourceMock.mutex.Lock()
	mmURLToSource.URLToSourceMock.callArgs = append(mmURLToSource.URLToSourceMock.callArgs, mm_params)
	mmURLToSource.URLToSourceMock.mutex.Unlock()

	for _, e := range mmURLToSource.URLToSourceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmURLToSource.URLToSourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmURLToSource.URLToSourceMock.defaultExpectation.Counter, 1)
		mm_want := mmURLToSource.URLToSourceMock.defaultExpectation.params
		mm_got := URLReplacerMockURLToSourceParams{parsedURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmURLToSource.t.Errorf("URLReplacerMock.URLToSource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmURLToSource.URLToSourceMock.defaultExpectation.results
		if mm_results == nil {
			mmURLToSource.t.Fatal("No results are set for the URLReplacerMock.URLToSource")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmURLToSource.funcURLToSource != nil {
		return mmURLToSource.funcURLToSource(parsedURL)
	}
	mmURLToSource.t.Fatalf("Unexpected call to URLReplacerMock.URLToSource. %v", parsedURL)
	return
}

// URLToSourceAfterCounter returns a count of finished URLReplacerMock.URLToSource invocations
func (mmURLToSource *URLReplacerMock) URLToSourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmURLToSource.afterURLToSourceCounter)
}

// URLToSourceBeforeCounter returns a count of URLReplacerMock.URLToSource invocations
func (mmURLToSource *URLReplacerMock) URLToSourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmURLToSource.beforeURLToSourceCounter)
}

// Calls returns a list of arguments used in each call to URLReplacerMock.URLToSource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmURLToSource *mURLReplacerMockURLToSource) Calls() []*URLReplacerMockURLToSourceParams {
	mmURLToSource.mutex.RLock()

	argCopy := make([]*URLReplacerMockURLToSourceParams, len(mmURLToSource.callArgs))
	copy(argCopy, mmURLToSource.callArgs)

	mmURLToSource.mutex.RUnlock()

	return argCopy
}

// MinimockURLToSourceDone returns true if the count of the URLToSource invocations corresponds
// the number of defined expectations
func (m *URLReplacerMock) MinimockURLToSourceDone() bool {
	for _, e := range m.URLToSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.URLToSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterURLToSourceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcURLToSource != nil && mm_atomic.LoadUint64(&m.afterURLToSourceCounter) < 1 {
		return false
	}
	return true
}

// MinimockURLToSourceInspect logs each unmet expectation
func (m *URLReplacerMock) MinimockURLToSourceInspect() {
	for _, e := range m.URLToSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLReplacerMock.URLToSource with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.URLToSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterURLToSourceCounter) < 1 {
		if m.URLToSourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLReplacerMock.URLToSource")
		} else {
			m.t.Errorf("Expected call to URLReplacerMock.URLToSource with params: %#v", *m.URLToSourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcURLToSource != nil && mm_atomic.LoadUint64(&m.afterURLToSourceCounter) < 1 {
		m.t.Error("Expected call to URLReplacerMock.URLToSource")
	}
}

type mURLReplacerMockURLToTarget struct {
	mock               *URLReplacerMock
	defaultExpectation *URLReplacerMockURLToTargetExpectation
	expectations       []*URLReplacerMockURLToTargetExpectation

	callArgs []*URLReplacerMockURLToTargetParams
	mutex    sync.RWMutex
}

// URLReplacerMockURLToTargetExpectation specifies expectation struct of the URLReplacer.URLToTarget
type URLReplacerMockURLToTargetExpectation struct {
	mock    *URLReplacerMock
	params  *URLReplacerMockURLToTargetParams
	results *URLReplacerMockURLToTargetResults
	Counter uint64
}

// URLReplacerMockURLToTargetParams contains parameters of the URLReplacer.URLToTarget
type URLReplacerMockURLToTargetParams struct {
	parsedURL *url.URL
}

// URLReplacerMockURLToTargetResults contains results of the URLReplacer.URLToTarget
type URLReplacerMockURLToTargetResults struct {
	s1  string
	err error
}

// Expect sets up expected params for URLReplacer.URLToTarget
func (mmURLToTarget *mURLReplacerMockURLToTarget) Expect(parsedURL *url.URL) *mURLReplacerMockURLToTarget {
	if mmURLToTarget.mock.funcURLToTarget != nil {
		mmURLToTarget.mock.t.Fatalf("URLReplacerMock.URLToTarget mock is already set by Set")
	}

	if mmURLToTarget.defaultExpectation == nil {
		mmURLToTarget.defaultExpectation = &URLReplacerMockURLToTargetExpectation{}
	}

	mmURLToTarget.defaultExpectation.params = &URLReplacerMockURLToTargetParams{parsedURL}
	for _, e := range mmURLToTarget.expectations {
		if minimock.Equal(e.params, mmURLToTarget.defaultExpectation.params) {
			mmURLToTarget.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmURLToTarget.defaultExpectation.params)
		}
	}

	return mmURLToTarget
}

// Inspect accepts an inspector function that has same arguments as the URLReplacer.URLToTarget
func (mmURLToTarget *mURLReplacerMockURLToTarget) Inspect(f func(parsedURL *url.URL)) *mURLReplacerMockURLToTarget {
	if mmURLToTarget.mock.inspectFuncURLToTarget != nil {
		mmURLToTarget.mock.t.Fatalf("Inspect function is already set for URLReplacerMock.URLToTarget")
	}

	mmURLToTarget.mock.inspectFuncURLToTarget = f

	return mmURLToTarget
}

// Return sets up results that will be returned by URLReplacer.URLToTarget
func (mmURLToTarget *mURLReplacerMockURLToTarget) Return(s1 string, err error) *URLReplacerMock {
	if mmURLToTarget.mock.funcURLToTarget != nil {
		mmURLToTarget.mock.t.Fatalf("URLReplacerMock.URLToTarget mock is already set by Set")
	}

	if mmURLToTarget.defaultExpectation == nil {
		mmURLToTarget.defaultExpectation = &URLReplacerMockURLToTargetExpectation{mock: mmURLToTarget.mock}
	}
	mmURLToTarget.defaultExpectation.results = &URLReplacerMockURLToTargetResults{s1, err}
	return mmURLToTarget.mock
}

//Set uses given function f to mock the URLReplacer.URLToTarget method
func (mmURLToTarget *mURLReplacerMockURLToTarget) Set(f func(parsedURL *url.URL) (s1 string, err error)) *URLReplacerMock {
	if mmURLToTarget.defaultExpectation != nil {
		mmURLToTarget.mock.t.Fatalf("Default expectation is already set for the URLReplacer.URLToTarget method")
	}

	if len(mmURLToTarget.expectations) > 0 {
		mmURLToTarget.mock.t.Fatalf("Some expectations are already set for the URLReplacer.URLToTarget method")
	}

	mmURLToTarget.mock.funcURLToTarget = f
	return mmURLToTarget.mock
}

// When sets expectation for the URLReplacer.URLToTarget which will trigger the result defined by the following
// Then helper
func (mmURLToTarget *mURLReplacerMockURLToTarget) When(parsedURL *url.URL) *URLReplacerMockURLToTargetExpectation {
	if mmURLToTarget.mock.funcURLToTarget != nil {
		mmURLToTarget.mock.t.Fatalf("URLReplacerMock.URLToTarget mock is already set by Set")
	}

	expectation := &URLReplacerMockURLToTargetExpectation{
		mock:   mmURLToTarget.mock,
		params: &URLReplacerMockURLToTargetParams{parsedURL},
	}
	mmURLToTarget.expectations = append(mmURLToTarget.expectations, expectation)
	return expectation
}

// Then sets up URLReplacer.URLToTarget return parameters for the expectation previously defined by the When method
func (e *URLReplacerMockURLToTargetExpectation) Then(s1 string, err error) *URLReplacerMock {
	e.results = &URLReplacerMockURLToTargetResults{s1, err}
	return e.mock
}

// URLToTarget implements urlreplacer.URLReplacer
func (mmURLToTarget *URLReplacerMock) URLToTarget(parsedURL *url.URL) (s1 string, err error) {
	mm_atomic.AddUint64(&mmURLToTarget.beforeURLToTargetCounter, 1)
	defer mm_atomic.AddUint64(&mmURLToTarget.afterURLToTargetCounter, 1)

	if mmURLToTarget.inspectFuncURLToTarget != nil {
		mmURLToTarget.inspectFuncURLToTarget(parsedURL)
	}

	mm_params := &URLReplacerMockURLToTargetParams{parsedURL}

	// Record call args
	mmURLToTarget.URLToTargetMock.mutex.Lock()
	mmURLToTarget.URLToTargetMock.callArgs = append(mmURLToTarget.URLToTargetMock.callArgs, mm_params)
	mmURLToTarget.URLToTargetMock.mutex.Unlock()

	for _, e := range mmURLToTarget.URLToTargetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmURLToTarget.URLToTargetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmURLToTarget.URLToTargetMock.defaultExpectation.Counter, 1)
		mm_want := mmURLToTarget.URLToTargetMock.defaultExpectation.params
		mm_got := URLReplacerMockURLToTargetParams{parsedURL}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmURLToTarget.t.Errorf("URLReplacerMock.URLToTarget got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmURLToTarget.URLToTargetMock.defaultExpectation.results
		if mm_results == nil {
			mmURLToTarget.t.Fatal("No results are set for the URLReplacerMock.URLToTarget")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmURLToTarget.funcURLToTarget != nil {
		return mmURLToTarget.funcURLToTarget(parsedURL)
	}
	mmURLToTarget.t.Fatalf("Unexpected call to URLReplacerMock.URLToTarget. %v", parsedURL)
	return
}

// URLToTargetAfterCounter returns a count of finished URLReplacerMock.URLToTarget invocations
func (mmURLToTarget *URLReplacerMock) URLToTargetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmURLToTarget.afterURLToTargetCounter)
}

// URLToTargetBeforeCounter returns a count of URLReplacerMock.URLToTarget invocations
func (mmURLToTarget *URLReplacerMock) URLToTargetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmURLToTarget.beforeURLToTargetCounter)
}

// Calls returns a list of arguments used in each call to URLReplacerMock.URLToTarget.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmURLToTarget *mURLReplacerMockURLToTarget) Calls() []*URLReplacerMockURLToTargetParams {
	mmURLToTarget.mutex.RLock()

	argCopy := make([]*URLReplacerMockURLToTargetParams, len(mmURLToTarget.callArgs))
	copy(argCopy, mmURLToTarget.callArgs)

	mmURLToTarget.mutex.RUnlock()

	return argCopy
}

// MinimockURLToTargetDone returns true if the count of the URLToTarget invocations corresponds
// the number of defined expectations
func (m *URLReplacerMock) MinimockURLToTargetDone() bool {
	for _, e := range m.URLToTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.URLToTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterURLToTargetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcURLToTarget != nil && mm_atomic.LoadUint64(&m.afterURLToTargetCounter) < 1 {
		return false
	}
	return true
}

// MinimockURLToTargetInspect logs each unmet expectation
func (m *URLReplacerMock) MinimockURLToTargetInspect() {
	for _, e := range m.URLToTargetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to URLReplacerMock.URLToTarget with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.URLToTargetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterURLToTargetCounter) < 1 {
		if m.URLToTargetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to URLReplacerMock.URLToTarget")
		} else {
			m.t.Errorf("Expected call to URLReplacerMock.URLToTarget with params: %#v", *m.URLToTargetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcURLToTarget != nil && mm_atomic.LoadUint64(&m.afterURLToTargetCounter) < 1 {
		m.t.Error("Expected call to URLReplacerMock.URLToTarget")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *URLReplacerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockToSourceInspect()

		m.MinimockToTargetInspect()

		m.MinimockURLToSourceInspect()

		m.MinimockURLToTargetInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *URLReplacerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *URLReplacerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockToSourceDone() &&
		m.MinimockToTargetDone() &&
		m.MinimockURLToSourceDone() &&
		m.MinimockURLToTargetDone()
}
